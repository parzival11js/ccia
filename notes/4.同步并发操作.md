# 同步并发操作
## 4.1 等待一个事件或其他条件
### 4.1.1 使用条件变量等待条件
- std::condition_variable: 仅限和std::mutex一起使用
- std::condition_variable_any: 可以使用任何满足蕾丝互斥锁的最低标准的对象
  ```
  std::mutex mu;
  std::queue<data_chunk> data_queue;
  std::condition_variable data_cond;

  void data_preparation_thread() {
    while (more_data_to_prepare()) {
      data_chunk const data = prepare_data();
      {
        std::lock_guard<std::mutex> lock(mu);
        data_queue.push(data);
      }
      // 解锁之后通知条件变量，为了，如果等待线程立即醒来，它没有必要再被阻塞在等待解锁互斥锁
      data_conf.notify_one();
    }
  }

  void data_processing_thread() {
    while (true) {
      // 使用unique_lock, 当wait条件不满足的时候解锁互斥锁, 将线程置于等待状态
      // 当准备数据的线程调用notify_one通知变量时，处理线程醒来并重新获取互斥锁上的锁
      std::unique_lock<std::mutex> lock(mu);
      data_cond.wait(lock, []{return !data_queue.empty();});
      data_chunk data = data_queue.front();
      data_queue.pop();
      lock.unlock();
      process(data);
      if (is_last_chunk(data)) {
        break;
      }
    }
  }
  ```
- 伪唤醒
  - wait期间条件变量可以对提供的条件检查任意次
  - 当等待的线程重新获取互斥锁并检查条件时，如果它不是直接响应来自另一个线程的通知，则称为伪唤醒(spurious weakup)
  - 伪唤醒的数量和频率都是不确定的，所以不建议使用具有副作用的函数进行条件检查

### 4.1.2 使用条件变量构建线程安全队列

## 4.2 使用期望等待一次性事件
- std::future
- std::shared_future
  - 多线程应该访问自己的std::shared_future副本，无需进一步同步

# 4.2.1 从后台任务返回值
- std::async
	- 基本使用
  	```
  	#include <futurue>  // std::async
  	#include <iostream>
		
		int find_the_answer_to_ltuae();
		void do_other_stuff();
		int main() {
			std::future<int> answer = std::async(find_the_answer_to_ltuae);
			do_other_stuff();
			std::cout << "The anwser is " << answer.get() << std::endl;
			return 0;
		}
  	```
	- 参数
		- std::async允许传递额外参数给函数，类似std::thread
		- 如果第一个参数是指向成员函数的指针，那么第二个参数就是应用成员函数的对象（要么直接是对象，要么通过指针，或包装在std::ref中, 其余参数作为成员函数的参数传递
		- 如果第一个参数不是指向成员函数的指针，那么第二个和随后的参数将作为函数或可调用对象的的参数传入
		- 当参数为右值时，拷贝操作将使用移动的方式转移原始数据, 这就允许只支持移动的类型作为函数对象和参数
